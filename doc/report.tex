\documentclass[letterpaper, 12pt, titlepage]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[margin=1in]{geometry}
\usepackage[]{parskip}
\usepackage{graphicx}
\usepackage{paralist} % compactitem
\usepackage{multirow}
\usepackage{longtable}
\usepackage{float}

% Custom commands
\newcommand{\figRef}[1]{Figure \ref{#1}}
\newcommand{\tabRef}[1]{Table \ref{#1}}
\newcommand{\eqRef}[1]{(\ref{#1})}

\title{Compiler Project Report}
\author{
  Wayne Stegner
}
\date{
  \today
}

\begin{document}
  \maketitle
  \par \textbf{Code Structure}
  \par My compiler is written in C++ with an object-oriented approach.
  It contains the following:

  \par \textbf{Scanner:} The scanner is simple enough.
  It outputs 1 token at a time when requested from the Parser.
  It doesn't touch the symbol table because it lacks semantics relative to
  the Parser.

  \par \textbf{Parser:}
  The parser is a recursive descent parser, as per the project spec.
  It is what I would consider the ``main'' module, and it drives all of the
  other components of the compiler.
  Some modifications to the grammar were made to simplify the parse.
  The declaration lists and statement lists were given their own definitions
  to make it flow a little better.
  The \texttt{expression} and other operator nodes had left recursion and were
  broken into two nodes, adding the \texttt{Prime} variant of each.
  The originally named nodes don't do much in the parse; they call the parsing
  of the left-hand side of the parse tree, then they hand the information to
  the \texttt{Prime} nodes for parsing the right-hand side, and that is where
  the fun stuff happens (type checking and code generation, namely).

  \par \textbf{Symbol Table/Environment:}
  The symbol table and scoping rules are encapsulated in the environment, which
  holds a global symbol table and then a stack of local symbol tables.
  The symbol tables hold the tokens from the scanner, which hold lots of
  semantic information used throughout the compilation process.
  The environment handles variable scoping for the parser during lookups.

  \par \textbf{Type Checker:}
  The type checker holds some helper functions to make sure types are
  compatible for the given operators.
  The parser invokes the type checking functions right before code generation
  stages which deal with types.
  Type checking also checks array sizes.

  \par \textbf{Error Recovery:}
  There are a couple of error recovery strategies.
  Type checking violations raise an error, but do not impede the flow of the
  parser, as long as the code is syntactically correct.
  However, unexpected tokens cause a panic mode, which syncs on \texttt{;} and
  \texttt{EOF} tokens.
  A panic will cause the current production to be dropped, although it doesn't
  always happen super cleanly.
  As they say: garbage in, garbage out.

  \par \textbf{Code Generation:}
  I tried several different code generation methods, but I found generating the
  \texttt{llvm} commands by hand to be the best route for me.
  (I wanted to use the API but I could not figure out how to install it\ldots
  \texttt{vim} users, am I right?)
  I made my own module to generate the necessary commands broken into several
  sections which I merge into 1 string at the end and emit to a file.
  The basic principle is to store and manage handles to \texttt{llvm} objects,
  which makes it easy to string together a multitude of commands.
  It's not the most efficient, but that's what optimization passes are for,
  right?

  \par The biggest code generation challenges were dealing with nested
  procedures and branch structures.
  However, these were taken care of with a few well-thought-out stacks.
  There is a stack to store procedure information, such as the current register
  count, the code generated so far, and counters for labels.
  When a new procedure starts in the source code, a fresh procedure struct is
  pushed to the stack, and then when a procedure ends, the procedure struct is
  popped and emitted to the main body of code.
  A similar stack strategy is used for loops and if statements, though these
  stacks only contain the branch labels.

  \par \textbf{Runtime Environment:}
  The runtime was made by compiling a c program to a shared object and then
  loading that when running \texttt{lli}.
  The c program is in the \texttt{src/runtime} directory.

  \par \textbf{Running the Compiler:}
  Dependencies: \texttt{clang}/\texttt{llvm} 6.0.0, \texttt{make} 4.1,
  \texttt{gcc} 7.5.0.
  The \texttt{llvm} version is old because that's what was on my system and I
  had dependencies I did not want to break.
  Some of the syntax and semantics seem different from the version discussed in
  class, mostly regarding implied register numbering.
  \par Run \texttt{make} in the project root directory to compile my compiler
  and the runtime shared object.
  Then, generate the \texttt{.ll} file with \texttt{./bin/compiler -l 2 -i
  code.src} (assuming \texttt{code.src} is the relative path to the source
  file) (see \texttt{./bin/compiler -h for full usage}).
  The \texttt{.ll} file will emit to \texttt{bin/}, where you can compile it
  with \texttt{llvm-as bin/code.ll}, then fire up the interpreter with
  \texttt{lli --load=bin/runtime.so bin/code.bc}.
  \par Alternatively, running \texttt{make all} should \textit{hopefully} make
  all of the \texttt{.bc} files, then you can run them with the \texttt{lli}
  command above.
\end{document}
